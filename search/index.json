[{"content":"Git SUBMODULE 정리 서브모듈이란? Git 에서의 서브 모듈은 \u0026ldquo;Git 저장소 (메인 저장소) 안에 다른 Git 저장소 (서브 저장소 - 재사용 및 공유 가능한 공통 \u0026ldquo;모듈\u0026quot;들을 주로 의미) 를 디렉토리로 분리해 넣는 것\u0026rdquo; 입니다. 서브모듈에 포함된 데이터는 내 Git 저장소에 디렉토리를 생성하여 넣기 때문에 독립적으로 커밋을 관리할 수 있습니다. 이 때, 메인 저장소와 서브 저장소의 커밋들은 동기화되지 않으며, 별도로 관리하게 됩니다.\n서브모듈 시작하기 먼저, 서브 모듈을 사용하기 위해 메인 저장소와 서브 저장소를 각각 \u0026ldquo;main-repo\u0026rdquo; 와 \u0026ldquo;sub-repo\u0026rdquo; 의 이름으로 생성되었다고 가정합니다. 서브모듈을 포함하고자 하는 메인 프로젝트를 다운 받아봅니다.\n1 2 \u0026gt; **git clone git@github.com:user/main-repo.git** Cloning into \u0026#39;main-repo\u0026#39;... 그리고, 메인 프로젝트에서 다음 명령어를 실행하여 submodule 을 추가합니다.\ngit submodule add [repo-url] [path]\n여기서 repo-url 은 추가하고자 하는 서브모듈 저장소의 URL, path 는 submodule 을 포함시킬 하위 디렉토리의 path 를 의미합니다.\n1 2 3 4 5 6 \u0026gt; **git submodule add git@github.com:user/sub-repo.git sub** Cloning into \u0026#39;/Users/dev/main-repo/sub\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. git status 를 실행하여 현재 프로젝트에서 변경된 사항을 출력해봅시다.\n1 2 3 4 5 6 7 8 9 \u0026gt; **git status** On branch main No commits yet Changes to be committed: (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: .gitmodules new file: sub .gitmodules 라는 파일과, sub 라는 디렉토리가 새로 생긴 것을 확인할 수 있습니다.\n.gitmodules 는 다음과 같이, 서브 디렉토리와 하위 프로젝트 URL 의 매핑 정보를 담은 설정 파일입니다.\n1 2 3 4 \u0026gt; **vi gitmodules** [submodule \u0026#34;sub\u0026#34;] path = sub url = git@github.com:user/sub-repo.git path 에는 submodule 이 들어있는 경로가, url 에는 서브 저장소의 url 이 매핑되어 있습니다.\n이제 서브 모듈을 추가한 내용을 다음과 같이 메인 저장소의 remote 로 push 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 **\u0026gt; git add .** **\u0026gt; git commit -m \u0026#34;feat: add submodules\u0026#34;** [main (root-commit) 2f513f5] feat: add submodules 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub **\u0026gt; git push** Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Delta compression using up to 12 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 318 bytes | 318.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:user/main-repo.git * [new branch] main -\u0026gt; main 이러한 과정을 거치면, 메인 프로젝트에서 서브모듈을 시작할 준비는 완료됩니다!\n서브 모듈을 포함한 프로젝트 Clone 하기 서브모듈을 포함한 메인 프로젝트를 최초로 Clone 할 때에는 일반 프로젝트와 다르게 서브모듈에 대한 몇 가지 설정을 해주어야 합니다.\n바로, 1) 서브모듈 초기화 2) 서브모듈 업데이트 (리모트 저장소로부터 pull 받아오기) 두 가지 과정입니다.\n이 과정을 각각 수행하려면 다음과 같이 진행합니다.\n먼저, 메인 레포지토리를 clone 받아옵니다.\n1 2 3 4 5 6 7 **\u0026gt; git clone git@github.com:user/main-repo.git** Cloning into \u0026#39;main-repo\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. 다음으로 서브모듈을 초기화합니다. 서브 모듈 정보를 기반으로 로컬 환경설정 파일 준비하는 과정입니다.\n1 2 **\u0026gt; git submodule init** Submodule \u0026#39;sub\u0026#39; (git@github.com:user/sub-repo.git) registered for path \u0026#39;sub\u0026#39; 마지막으로, 서브모듈을 업데이트 (리모트 저장소로부터 pull 받아오기) 합니다.\n서브모듈 remote 저장소에서 데이터를 가져오고, 서브모듈을 포함한 프로젝트의 현재 스냅샷에서 Checkout 해야 할 커밋 정보를 가져와서 서브모듈 프로젝트에 대한 Checkout 하는 과정입니다.\n1 2 3 **\u0026gt; git submodule update** Cloning into \u0026#39;/Users/user/dev/main-repo/sub\u0026#39;... Submodule path \u0026#39;sub\u0026#39;: checked out \u0026#39;7e39f89295c7886ce1c60aa67a205063fe52e146\u0026#39; 이러한 과정을 clone 하면서 한번에 수행하고 싶다! 라고 하면, 다음과 같이 진행해주시면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 **\u0026gt; git clone --recurse-submodules git@github.com:user/main-repo.git** Cloning into \u0026#39;main-repo\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. Submodule \u0026#39;sub\u0026#39; (git@github.com:user/sub-repo.git) registered for path \u0026#39;sub\u0026#39; Cloning into \u0026#39;/Users/dev/main-repo/sub\u0026#39;... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (2/2), done. remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0 Receiving objects: 100% (6/6), done. Submodule path \u0026#39;sub\u0026#39;: checked out \u0026#39;7e39f89295c7886ce1c60aa67a205063fe52e146\u0026#39; 과정을 살펴보면,\n먼저 main-repo 의 데이터를 clone 받아오고, 서브 모듈을 초기화 (지정된 path 에 module 을 등록) 서브모듈을 업데이트 (리모트 저장소로부터 pull 받아오기) 하는 순서로 진행된 것을 확인할 수 있습니다. 서브모듈의 상태 확인 및 변경 사항 적용하기 프로젝트를 진행하다보면, 서브 모듈 레포지토리에 변경 사항이 발생할 때가 있을 것입니다. 앞서 말씀드린 것처럼, 메인 프로젝트의 커밋과 서브모듈의 커밋은 독립적으로 동작하기 때문에,\n서브 모듈의 변경사항이 발생할 때 해당 사항이 메인 프로젝트에 자동으로 반영되지 않습니다. 이 부분이 서브 모듈 사용 시에 주의해야 할 포인트입니다.\n메인 프로젝트에서 사용 중인 서브 모듈이 이전 버전을 반영하고 있을 수 있는 것이죠.\n이를 방지하기 위해 다음과 같이 서브 모듈의 상태를 주기적으로 확인하고, 변경 사항이 있을 시 적용해주는 것이 중요합니다.\n서브모듈의 상태를 확인하기 위해서는 다음의 커멘드를 실행합니다.\n1 2 **\u0026gt; git submodule status** 07b6383bae047572b5c4c7b8e41b5cdd7935c9c8 sub (heads/main) head 가 메인에 있으며, commit ID 를 확인해보니 최신 commit 을 가리키고 있는 것으로 보입니다.\n서브 모듈에 약간의 변경 사항을 적용하여 push 해보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 **\u0026gt; git add test.py** **\u0026gt; git commit -m \u0026#34;fix: add submodule\u0026#34;** [main 7e39f89] fix: test.py 1 file changed, 1 insertion(+), 1 deletion(-) \u0026gt; git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 267 bytes | 267.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:user/sub-repo.git 07b6383..7e39f89 main -\u0026gt; main 서브 모듈에 의 새로운 커밋을 push 하였습니다.\n다시 서브모듈의 상태를 확인하기 위해 다음의 커멘드를 실행합니다.\n1 2 **\u0026gt; git submodule status** 07b6383bae047572b5c4c7b8e41b5cdd7935c9c8 sub (heads/main) head 가 메인에 있으며, commit ID 를 확인해보니 여전히 이전 commit 을 가리키고 있는 것으로 보입니다.\n서브 모듈의 최신 상태를 업데이트하기 위해 다음의 커멘드를 실행합니다.\n1 2 3 4 5 6 7 8 **\u0026gt; git submodule update —remote** remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 247 bytes | 49.00 KiB/s, done. From github.com:user/sub-repo 07b6383..7e39f89 main -\u0026gt; origin/main Submodule path \u0026#39;sub\u0026#39;: checked out \u0026#39;7e39f89295c7886ce1c60aa67a205063fe52e146\u0026#39; 다시 서브 모듈의 상태를 확인해봅시다.\n1 2 **\u0026gt; git submodule status** +7e39f89295c7886ce1c60aa67a205063fe52e146 sub (remotes/origin/HEAD) 서브 모듈의 두 번째 commit ID 7e39f89295c7886ce1c60aa67a205063fe52e146 가 보여지고 있네요.\n서브모듈 실습 준비 실제 Github 활용해서 간단하게 테스트 해보려고 합니다. 아래와 같이 TestMain (Public Repository) 와 TestSub (Private Repository) 총 2개의 Repository를 생성했습니다.\nTestMain에는 README.md 파일만 존재하고\nTestSub에는 아래와 같이 test.properites 라는 파일과 README.md 파일이 존재합니다.\n실습 우선 다음과 같이 TestMain 레파지토리를 clone 합니다.\n1 2 3 4 5 6 7 hyungkeunchoi@HyungKeunui-MacBookPro DeskTop % git clone https://github.com/ChoiHyungKuen/TestMain Cloning into \u0026#39;TestMain\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. hyungkeunchoi@HyungKeunui-MacBookPro DeskTop % 이후 아래와 같이 명령어로 TestMain 폴더로 이동 후 TestSub 레파지토리를 sub라는 이름으로 서브 프로젝트를 생성합니다.\n1 2 3 4 5 6 7 8 9 hyungkeunchoi@HyungKeunui-MacBookPro DeskTop % cd TestMain hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git submodule add https://github.com/ChoiHyungKuen/TestSub.git sub Cloning into \u0026#39;/Users/hyungkeunchoi/Desktop/TestMain/sub\u0026#39;... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. hyungkeunchoi@HyungKeunui-MacBookPro TestMain % 이후에 TestMain 폴더를 VisualStudioCode로 열어서 폴더 구조를 확인 합니다.\n그러면 아래와 같이 .gitmodules 파일에 sub 라는 이름으로 TestSub 레파지토리가 서브 모듈로 생성되었다는 것을 확인 할 수 있습니다. 여기서 주목할 점은 TestSub가 아닌 sub 라는 이름으로 실제 폴더가 만들어졌다는 점입니다. 이렇게 만들어지면 일반적인 폴더와 똑같이 사용하면 됩니다.\n이후에 해당 서브모듈을 원격 저장소에 push를 하려면 다음과 같이 명령어를 입력하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git add . hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git commit -m \u0026#34;feat: add submodules\u0026#34; [main 870693c] feat: add submodules 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git push Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 8 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 397 bytes | 397.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/ChoiHyungKuen/TestMain 4b799a8..870693c main -\u0026gt; main hyungkeunchoi@HyungKeunui-MacBookPro TestMain % 그러면 아래와 같이 sub@d940787이라는 이름으로 서브모듈이 생긴 것을 확인 할 수 있습니다. 로그인 했을 때는 클릭하면 기존의 TestSub 레파지토리인 것을 확인할 수 있습니다.\n로그인 안 된 상태에서 해당 레파지토리에서 서브모듈을 클릭하게 되면 Private 레파지토리이기때문에 아래와 같이 404페이지를 띄워주어서 확인이 불가능 합니다.\n후기 해당 방법을 통해 민감 파일들을 private 레파지토리 하나를 생성해서 관리하는데 용이할 수 있습니다.\n프로젝트에는 데이터베이스 관련 설정, AWS 관련 설정, API Key와 같은 민감 데이터가 포함될 수 있습니다. 당연히 이와 같은 정보는 하드 코딩해선 안 되고, 별도의 설정 파일로 관리해야 한다. 그래서 SpringBoot에서는 application.properties 파일이나, application.yml 파일을 이용해 설정을 관리하는 것이 일반적입니다.\n설정 파일을 별도로 관리함으로써 얻을 수 있는 또 하나의 이점은, 각 환경에 따라 다른 설정을 적용할 수 있다는 것입니다. 즉, 로컬 환경(local-env), 개발 환경(dev-env), 운영 환경(prod-env), 테스트 환경(test-env)별로 다른 설정을 사용할 수 있게 됩니다.\n문제는 설정 파일을 팀원들과 어떻게 공유할 것인가 입니다. 설정 파일은 다른 사람에겐 공개되지 않으면서, 팀원들 간에는 원활히 공유되어야 합니다. 이러한 문제를 해결하는데 서브모듈을 활용할 수 있을 것입니다.\n위 실습과 여러가지 자료를 찾아본 종합적인 결과를 봤을 때, 개인적인 생각으로는 수정하지 않는 설정 파일이나 Key파일처럼 읽기만 하는 파일을 공유할 수 있는 비공개 레파지토리로 공유하는 것은 좋은 방법일 수 있습니다. 하지만 변경이 주기적으로 필요한 파일이 있는 경우에는 서브모듈 레파지토리를 따로 업데이트 해줘야 하기 때문에 번거로울 수 있을 것 같습니다.\nReference ","date":"2024-01-18T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/git-submodule-%EC%A0%95%EB%A6%AC/","title":"Git Submodule 정리"},{"content":"이번에 일감을 처리하다가 특정 URL에 대한 메뉴 정보를 어떻게 받아오는지 어떻게 처리하는지를 찾다가 해당 내용을 정리하면 좋을 것 같아서 적어본다.\nHandlerInterceptor는 특정한 URI 호출을 \u0026lsquo;가로채는\u0026rsquo; 역할을 합니다. 이를 이용하여 기존 컨트롤러의 로직을 수정하지 않고도, 사전이나 사후 제어가 가능합니다.\nHandlerIntercepter 제공 내부 메서드 1. preHandle(request, response, handler) 지정된 컨트롤러의 동작 이전에 수행할 동작 (사전 제어)\n2. postHandle(request, response, handler, modelAndView) 지정된 컨트롤러의 동작 이후에 처리할 동작 (사후 제어).\nSpring MVC의 Dispatcher Servlet이 화면을 처리하기 전에 동작.\n3. afterCompletion(request, reponse, handler, exception) Dispatcher Servlet의 화면 처리가 완료된 이후 처리할 동작.\nHandlerIntercepter와 Filter의 차이 두 기능 모두 특정 URI에 접근할 때 제어하는 용도로 사용됩니다. 두 기능의 가장 큰 차이는 Context(실행 영역)에 있습니다.\nFilter는 웹 어플리케이션 내에서 동작하기 때문에 Spring Context에 접근하기 어렵습니다.\n반면 Interceptor의 경우 Spring 영역 내에서 동작하기 때문에, Spring Context에 접근하기 용이합니다.\n주로 웹 애플리케이션에서는 이를 상속 받아서 AuthIntercepter 같은 이름의 클래스로 생성해서 특정 URL에 접근할 때 사용자의 권한에 따라 접근할 수 있는지 없는지 확인하는 용도로 사용한다.\n주로 다음의 형태로 사용된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SVG 안에 있는 텍스트는 css처럼 말줌임 옵션을 사용할 수 없어서 따로 로직 추가 function setEllipsisToText() { var self = d3.select(this), textLength = self.node().getComputedTextLength(), text = self.text(); // textLength (길이) 가 50이 넘으면 ... 표시 while (textLength \u0026gt; 50 \u0026amp;\u0026amp; text.length \u0026gt; 0) { text = text.slice(0, -1); self.text(text + \u0026#34;...\u0026#34;); textLength = self.node().getComputedTextLength(); } } // 이후에 text 태그를 순회하면서 자식태그인 tspan태그의 text를 다음과 같이 변경해주면 된다. $(\u0026#34;#amcharts_\u0026#34; + cid) .find(\u0026#34;text\u0026#34;) .each(function () { $(this) .find(\u0026#34;tspan\u0026#34;) .text(function (d) { return d.name; }) .each(setEllipsisToText); }); ","date":"2024-01-18T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/handlerintercepter/","title":"HandlerIntercepter"}]