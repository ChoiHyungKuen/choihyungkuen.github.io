[{"content":"Hydration Server Side에서 렌더링 된 정적 페이지(HTML)와 번들링 된 JS파일을 클라이언트에게 보내면, Client-Side에서 HTML 코드와 JS(React) 코드를 매칭시키는 과정을 Hydration이라고 한다. 참고로 Hydration은 “수분공급”이라는 뜻을 가지고 있는데 아무것도 없는 dummy html 파일에 JS 코드들이 DOM 요소 위에 물을 채우듯 필요로 하던 요소들을 채운다하여 붙여진 이름이라고 한다.\nHydration 진행과정 React로 페이지를 제작한다. Next.js는 React에서 HTML 파일을 생성하기 위한 React Server-Side API인 ReactDOMServer을 사용해 제작된 사이트의 프로덕션 단계 파일을 생성한다. 만약 이때 웹 페이지를 보게 된다면, 서버로부터 생성된 정적인 HTML 파일을 보게 될 것이다. 페이지 첫 로딩 이후 JS가 로드 되고, ReactDOM.hydrate() API는 JS와 함께 서버에서 렌더링되었던 HTML 페이지에 수분을 공급한다. Hydration 이후, React reconciler API가 자리를 대체하고, 사이트는 상호작용이 가능해진다. 더 나아가, Client Side에서 JS 파일이 렌더링 될 때, 단지 각 DOM 요소에 JS 속성을 매칭시킬 뿐 실제 웹 페이지를 다시 그리는 paint() 함수까지 호출하지않는다.\nuse client 위에서 언급된 hydration 과정이 모든 컴포넌트에 대해서는 발생하지 않는다. client side에서 상호작용이 가능하게 만들어지는 컴포넌트는 오직 use client라고 지시어를 붙인 컴포넌트들 뿐이다. 위에서 작성했던 컴포넌트들을 살펴보면 AboutUs 컴포넌트에는 use client 지시어가 없는 것을 볼 수 있는데 이는 hydrate 과정이 필요한 컴포넌트가 아니기 때문에 해당 지시어가 필요없다. 또한, 이렇게 구별이 된다면 사용자는 좀 더 적은 용량의 JS를 다운로드 받는다는 장점이 있다. (use client 가 없는 경우는 hydration이 필요없는 상태, 즉 JS가 필요없는 상태임을 의미한다.)\n","date":"2024-04-20T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/nextjs-hydration/","title":"NextJs Hydration"},{"content":"Routes 기존 react를 사용할 때는 React Router 라이브러리를 활용해서 아래와 같이 라이브러리에서 제공하는 컴포넌트를 활용해서 코드를 정의하여 url router를 사용할 수 있었다.\n1 2 3 4 5 6 7 8 9 10 11 12 const Router = () =\u0026gt; { return ( \u0026lt;BrowserRouter\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; element={\u0026lt;GalleryPage /\u0026gt;} /\u0026gt; \u0026lt;Route path=\u0026#34;/about-us\u0026#34; element={\u0026lt;AboutUs /\u0026gt;}\u0026gt; \u0026lt;Route path=\u0026#34;/movies/:id\u0026#34; element={\u0026lt;Movie /\u0026gt;} /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/BrowserRouter\u0026gt; ); }; 하지만 nextjs에서는 아래의 규칙을 활용하면 빠르고 쉽게 url router를 지정할 수 있다.\napp 폴더에 있는 page.tsx는 /(루트 경로) 이다. app 하위에 폴더를 만들면 그 폴더의 이름으로 url을 사용할 수 있다. 해당 route 폴더 안에는 반드시 page.tsx라는 이름으로 파일을 만들어야 한다. 예를 들어서 /about-us 라는 url 경로에 페이지를 만들고 싶으면 아래와 같이 작성해주면 된다.\n그러면 해당 url에 맞는 페이지가 뜨는 것을 확인 할 수 있다.\n좀 더 복잡한 url 형식으로 /about-us/company/sales 를 다음과 같이 만들 수 있다.\n하지만 page.tsx가 없는 /about-us/company 경로에 접속시 아래와 같은 404 메시지를 볼 수 있다. 이렇게 page.tsx 파일이 없는 경로는 그저 경로의 일부분이 된다.\n또한, page.tsx라는 이름이 아닌 다른 파일을 생성하게 되면 그 경로는 지정되지 않는다.\n","date":"2024-04-18T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/nextjs-route/","title":"NextJs Route"},{"content":"SSR vs CSR CSR CSR은 Client Side Rendering의 약자로, 말 그대로 SSR과 달리 렌더링이 클라이언트(브라우저) 쪽에서 일어난다.\n위의 사진은 CSR의 단계를 설명한다.\n1. User가 Website 요청을 보냄.\n2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.\nCDN : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 \u0026lsquo;물리적\u0026rsquo;으로 가까운 서버에서 요청에 응답하는 방식\n3, 4. 라이언트는 HTML과 JS를 다운로드 받는다.\n(이때 SSR과 달리 유저는 아무것도 볼 수 없다.)\n5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.\n(이때 유저들은 placeholder를 보게된다. )\n6. 서버가 API로부터의 요청에 응답한다.\n7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.\n즉, 서버에서 처리 없이 클라이언트로 보내주기 때문에 자바스크립트가 모두 다운로드 되고 실행이 끝나기 전까지 사용자는 볼 수 있는게 없다.\nSSR SSR은 Server Side Rendering의 약자로, 말 그대로 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식이다.\n위의 사진은 SSR의 단계를 설명한다.\nUser가 Website 요청을 보냄.\nServer는 \u0026lsquo;Ready to Render\u0026rsquo;. 즉, 즉시 렌더링 가능한 html파일을 만든다.\n(리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)\n클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다. 그러나 사이트 자체는 조작 불가능하다. (Javascript가 읽히기 전이다.) 4. 클라이언트가 자바스크립트를 다운받는다. 5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다. 6. 브라우저가 Javascript 프레임워크를 실행한다. 7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.\n즉, 서버에서 이미 ‘렌더 가능한’ 상태로 클라이언트에 전달되기 때문에, JS가 다운로드 되는 동안 사용자는 무언가를 보고 있을 수 있다.\n두 방식의 차이점 1. 웹페이지를 로딩하는 시간 웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다.\n하나는 웹 사이트의 가장 첫 페이지를 로딩하는 것. 다른 하나는 나머지를 로딩하는 것.\n첫 페이지 로딩시간\nCSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다. ⇒ 따라서 평균적으로 SSR이 더 빠르다.\n나머지 로딩 시간\n첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.\n반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.\n2. SEO 대응 검색 엔진은 자동화된 로봇인 \u0026lsquo;크롤러\u0026rsquo;로 웹 사이트들을 읽는다. CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행 되어야 meatadata가 바뀌었다.\n(이전 크롤러들은 자바스크립트를 실행시키지 않았었기에 SEO 최적화가 필수적이었다. 구글이 그 트렌드를 바꾸고 있다고 한다.)\nSSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.\n3. 서버 자원 사용 SSR이 서버 자원을 더 많이 사용한다. 매번 서버에 요청을 하기 때문이다. 리엑트로 구현할 때는 다음과 같은 문제가 생기기도 한다.\nrenderToStrng은 React에서 서버사이드 렌더링을 구현하는데 사용되는 메소드다. 그런데 이게 스택을 막고 동기적으로 처리된다. 이게 실행될 동안 서버는 멈춘다. ","date":"2024-04-15T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/nextjs-%EC%8B%9C%EC%9E%91%ED%95%B4%EB%B3%B4%EA%B8%B0/","title":"NextJs 시작해보기"},{"content":"아래 명령어로 프로제트 초기화\n1 2 \u0026gt; npm init -y \u0026gt; npm install react@latest next@latest react-dom@latest package.json에 scripts 부분 수정\n1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;next dev\u0026#34; } 해당 프로젝트 폴더에 app/page.tsx 파일 만들고 아래 내용 작성\n반드시 page.tsx라는 이름의 파일로 만들어야 / (루트)에 라우팅 페이지가 만들어진다.\n1 2 3 export default function Page() { return \u0026lt;h1\u0026gt;Hello NextJS!\u0026lt;/h1\u0026gt;; } 에디터에서 아래와 같이 에러가 발생할 수 있다.\n해당 에러는 typescript가 설치되지 않았다고 뜨는 문제인데 아래의 명령어를 수행하면 typesciprt와 더불어 필요한 라이브러리들이 자동으로 설치 된다.\n1 \u0026gt; npm run dev 이후에 터미널에서 “Local: http://localhost:3001”로 뜨는데 해당 주소를 들어가면 아래와 같이 웹페이지가 뜨는 것을 확인 할 수 있다.\n","date":"2024-04-12T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/nextjs-%EC%8B%9C%EC%9E%91%ED%95%B4%EB%B3%B4%EA%B8%B0/","title":"NextJs 시작해보기"},{"content":"Next.js란? React 를 기반으로하는 웹 개발 프레임워크이다. Next.js는 웹 애플리케이션 개발에 있어 매력적인 선택지로 만드는 여러 가지 주요 기능과 장점을 제공한다.\n자동 코드 분할 : Next.js는 각 페이지에서 사용되는 컴포넌트를 기반으로 애플리케이션 코드를 자동으로 작은 번들로 분할하여 사용자가 현재 페이지에 필요한 코드만 다운로드하도록 한다. 이로 인해 로딩 시간이 단축되고 성능이 향상된다. 핫 모듈 교체 : Next.js는 핫 모듈 교체(HMR)를 지원하여 개발자들이 전체 페이지를 새로 고치지 않고도 애플리케이션의 변경 사항을 볼 수 있다. 이는 개발 경험을 크게 향상시키고 개발 프로세스를 가속화한다. 자동 페이지 라우팅: Next.js는 \u0026ldquo;pages\u0026rdquo; 디렉토리의 파일 구조를 기반으로 자동으로 페이지 라우팅을 처리한다. 이를 통해 개발 프로세스가 간소화되고 수동으로 라우트를 구성할 필요가 없어진다. 통합된 API 개발 : Next.js는 개발자들이 애플리케이션 내에서 쉽게 서버리스 API 경로를 생성할 수 있도록 지원하여 풀 스택 애플리케이션 개발 프로세스를 간소화하고 프론트엔드와 백엔드 간의 원활한 통신을 가능하게 한다. 하이브리드 렌더링 : Next.js는 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 모두 지원하여 개발자들이 특정 사용 사례에 가장 적합한 방식을 선택하거나 하나의 애플리케이션 내에서 두 기술을 결합할 수 있다. 내장된 CSS 및 JavaScript 지원 : Next.js에는 CSS 모듈 및 styled-components와 같은 인기 있는 CSS-in-JS 솔루션에 대한 내장 지원이 포함되어 있다. 또한 ES 모듈과 동적 임포트와 같은 현대적인 JavaScript 기능을 지원한다. 확장성 : Next.js는 플러그인, 미들웨어, 사용자 정의 설정을 통해 쉽게 확장할 수 있도록 설계되었다. 이를 통해 개발자들은 프레임워크를 특정 요구에 맞게 맞춤화하고 다른 도구와 서비스통합할 수 있다. 큰 규모의 활발한 커뮤니티 : Next.js에는 지속적으로 개발과 유지보수가 이루어지는 많은 개발자들로 이루어진 커뮤니티가 있다. 이 활발한 커뮤니티는 Next.js 애플리케이션의 기능을 확장하고 일반적인 개발 과제를 해결하기 위한 다양한 리소스, 제3자 라이브러리, 도구를 제공한다. ","date":"2024-04-12T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/nextjs%EB%9E%80/","title":"NextJs란?"},{"content":"기존에는 span, h1 등의 태그 내부의 텍스트가 길어질 경우에는 보통 다음과 같이 작성하여 말줄임 표시(…)를 CSS로 설정해준다.\n1 2 3 4 5 .test { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } 하지만 이와 달리 svg 내부에 있는 text-tspan 태그의 경우에는 위의 css가 적용이 안 된다. 이유를 추측해보면 이미 크기랑 위치가 property 형태로 제공되기 때문인 것 같다.\n그래서 말줄임 표시를 해주고 싶으면 다음과 같은 자바스크립트를 통해 변경하는 로직을 넣어주어야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SVG 안에 있는 텍스트는 css처럼 말줌임 옵션을 사용할 수 없어서 따로 로직 추가 function setEllipsisToText() { var self = d3.select(this), textLength = self.node().getComputedTextLength(), text = self.text(); // textLength (길이) 가 50이 넘으면 ... 표시 while (textLength \u0026gt; 50 \u0026amp;\u0026amp; text.length \u0026gt; 0) { text = text.slice(0, -1); self.text(text + \u0026#34;...\u0026#34;); textLength = self.node().getComputedTextLength(); } } // 이후에 text 태그를 순회하면서 자식태그인 tspan태그의 text를 다음과 같이 변경해주면 된다. $(\u0026#34;#amcharts_\u0026#34; + cid) .find(\u0026#34;text\u0026#34;) .each(function () { $(this) .find(\u0026#34;tspan\u0026#34;) .text(function (d) { return d.name; }) .each(setEllipsisToText); }); 또한, 위 코드를 사용하기 위해서는 사전에 d3.js라는 시각화 라이브러리를 import해주어야 한다.\n","date":"2024-03-12T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/jquery-svg-%EB%82%B4%EB%B6%80-%EA%B8%80%EA%BC%B4-%EB%A7%90%EC%A4%84%EC%9E%84-%ED%91%9C%EC%8B%9C/","title":"jquery - svg 내부 글꼴 말줄임 표시"},{"content":"Git SUBMODULE 정리 서브모듈이란? Git 에서의 서브 모듈은 \u0026ldquo;Git 저장소 (메인 저장소) 안에 다른 Git 저장소 (서브 저장소 - 재사용 및 공유 가능한 공통 \u0026ldquo;모듈\u0026quot;들을 주로 의미) 를 디렉토리로 분리해 넣는 것\u0026rdquo; 입니다. 서브모듈에 포함된 데이터는 내 Git 저장소에 디렉토리를 생성하여 넣기 때문에 독립적으로 커밋을 관리할 수 있습니다. 이 때, 메인 저장소와 서브 저장소의 커밋들은 동기화되지 않으며, 별도로 관리하게 됩니다.\n서브모듈 시작하기 먼저, 서브 모듈을 사용하기 위해 메인 저장소와 서브 저장소를 각각 \u0026ldquo;main-repo\u0026rdquo; 와 \u0026ldquo;sub-repo\u0026rdquo; 의 이름으로 생성되었다고 가정합니다. 서브모듈을 포함하고자 하는 메인 프로젝트를 다운 받아봅니다.\n1 2 \u0026gt; **git clone git@github.com:user/main-repo.git** Cloning into \u0026#39;main-repo\u0026#39;... 그리고, 메인 프로젝트에서 다음 명령어를 실행하여 submodule 을 추가합니다.\ngit submodule add [repo-url] [path]\n여기서 repo-url 은 추가하고자 하는 서브모듈 저장소의 URL, path 는 submodule 을 포함시킬 하위 디렉토리의 path 를 의미합니다.\n1 2 3 4 5 6 \u0026gt; **git submodule add git@github.com:user/sub-repo.git sub** Cloning into \u0026#39;/Users/dev/main-repo/sub\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. git status 를 실행하여 현재 프로젝트에서 변경된 사항을 출력해봅시다.\n1 2 3 4 5 6 7 8 9 \u0026gt; **git status** On branch main No commits yet Changes to be committed: (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: .gitmodules new file: sub .gitmodules 라는 파일과, sub 라는 디렉토리가 새로 생긴 것을 확인할 수 있습니다.\n.gitmodules 는 다음과 같이, 서브 디렉토리와 하위 프로젝트 URL 의 매핑 정보를 담은 설정 파일입니다.\n1 2 3 4 \u0026gt; **vi gitmodules** [submodule \u0026#34;sub\u0026#34;] path = sub url = git@github.com:user/sub-repo.git path 에는 submodule 이 들어있는 경로가, url 에는 서브 저장소의 url 이 매핑되어 있습니다.\n이제 서브 모듈을 추가한 내용을 다음과 같이 메인 저장소의 remote 로 push 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 **\u0026gt; git add .** **\u0026gt; git commit -m \u0026#34;feat: add submodules\u0026#34;** [main (root-commit) 2f513f5] feat: add submodules 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub **\u0026gt; git push** Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Delta compression using up to 12 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 318 bytes | 318.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:user/main-repo.git * [new branch] main -\u0026gt; main 이러한 과정을 거치면, 메인 프로젝트에서 서브모듈을 시작할 준비는 완료됩니다!\n서브 모듈을 포함한 프로젝트 Clone 하기 서브모듈을 포함한 메인 프로젝트를 최초로 Clone 할 때에는 일반 프로젝트와 다르게 서브모듈에 대한 몇 가지 설정을 해주어야 합니다.\n바로, 1) 서브모듈 초기화 2) 서브모듈 업데이트 (리모트 저장소로부터 pull 받아오기) 두 가지 과정입니다.\n이 과정을 각각 수행하려면 다음과 같이 진행합니다.\n먼저, 메인 레포지토리를 clone 받아옵니다.\n1 2 3 4 5 6 7 **\u0026gt; git clone git@github.com:user/main-repo.git** Cloning into \u0026#39;main-repo\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. 다음으로 서브모듈을 초기화합니다. 서브 모듈 정보를 기반으로 로컬 환경설정 파일 준비하는 과정입니다.\n1 2 **\u0026gt; git submodule init** Submodule \u0026#39;sub\u0026#39; (git@github.com:user/sub-repo.git) registered for path \u0026#39;sub\u0026#39; 마지막으로, 서브모듈을 업데이트 (리모트 저장소로부터 pull 받아오기) 합니다.\n서브모듈 remote 저장소에서 데이터를 가져오고, 서브모듈을 포함한 프로젝트의 현재 스냅샷에서 Checkout 해야 할 커밋 정보를 가져와서 서브모듈 프로젝트에 대한 Checkout 하는 과정입니다.\n1 2 3 **\u0026gt; git submodule update** Cloning into \u0026#39;/Users/user/dev/main-repo/sub\u0026#39;... Submodule path \u0026#39;sub\u0026#39;: checked out \u0026#39;7e39f89295c7886ce1c60aa67a205063fe52e146\u0026#39; 이러한 과정을 clone 하면서 한번에 수행하고 싶다! 라고 하면, 다음과 같이 진행해주시면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 **\u0026gt; git clone --recurse-submodules git@github.com:user/main-repo.git** Cloning into \u0026#39;main-repo\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. Submodule \u0026#39;sub\u0026#39; (git@github.com:user/sub-repo.git) registered for path \u0026#39;sub\u0026#39; Cloning into \u0026#39;/Users/dev/main-repo/sub\u0026#39;... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (2/2), done. remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0 Receiving objects: 100% (6/6), done. Submodule path \u0026#39;sub\u0026#39;: checked out \u0026#39;7e39f89295c7886ce1c60aa67a205063fe52e146\u0026#39; 과정을 살펴보면,\n먼저 main-repo 의 데이터를 clone 받아오고, 서브 모듈을 초기화 (지정된 path 에 module 을 등록) 서브모듈을 업데이트 (리모트 저장소로부터 pull 받아오기) 하는 순서로 진행된 것을 확인할 수 있습니다. 서브모듈의 상태 확인 및 변경 사항 적용하기 프로젝트를 진행하다보면, 서브 모듈 레포지토리에 변경 사항이 발생할 때가 있을 것입니다. 앞서 말씀드린 것처럼, 메인 프로젝트의 커밋과 서브모듈의 커밋은 독립적으로 동작하기 때문에,\n서브 모듈의 변경사항이 발생할 때 해당 사항이 메인 프로젝트에 자동으로 반영되지 않습니다. 이 부분이 서브 모듈 사용 시에 주의해야 할 포인트입니다.\n메인 프로젝트에서 사용 중인 서브 모듈이 이전 버전을 반영하고 있을 수 있는 것이죠.\n이를 방지하기 위해 다음과 같이 서브 모듈의 상태를 주기적으로 확인하고, 변경 사항이 있을 시 적용해주는 것이 중요합니다.\n서브모듈의 상태를 확인하기 위해서는 다음의 커멘드를 실행합니다.\n1 2 **\u0026gt; git submodule status** 07b6383bae047572b5c4c7b8e41b5cdd7935c9c8 sub (heads/main) head 가 메인에 있으며, commit ID 를 확인해보니 최신 commit 을 가리키고 있는 것으로 보입니다.\n서브 모듈에 약간의 변경 사항을 적용하여 push 해보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 **\u0026gt; git add test.py** **\u0026gt; git commit -m \u0026#34;fix: add submodule\u0026#34;** [main 7e39f89] fix: test.py 1 file changed, 1 insertion(+), 1 deletion(-) \u0026gt; git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 267 bytes | 267.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:user/sub-repo.git 07b6383..7e39f89 main -\u0026gt; main 서브 모듈에 의 새로운 커밋을 push 하였습니다.\n다시 서브모듈의 상태를 확인하기 위해 다음의 커멘드를 실행합니다.\n1 2 **\u0026gt; git submodule status** 07b6383bae047572b5c4c7b8e41b5cdd7935c9c8 sub (heads/main) head 가 메인에 있으며, commit ID 를 확인해보니 여전히 이전 commit 을 가리키고 있는 것으로 보입니다.\n서브 모듈의 최신 상태를 업데이트하기 위해 다음의 커멘드를 실행합니다.\n1 2 3 4 5 6 7 8 **\u0026gt; git submodule update —remote** remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 247 bytes | 49.00 KiB/s, done. From github.com:user/sub-repo 07b6383..7e39f89 main -\u0026gt; origin/main Submodule path \u0026#39;sub\u0026#39;: checked out \u0026#39;7e39f89295c7886ce1c60aa67a205063fe52e146\u0026#39; 다시 서브 모듈의 상태를 확인해봅시다.\n1 2 **\u0026gt; git submodule status** +7e39f89295c7886ce1c60aa67a205063fe52e146 sub (remotes/origin/HEAD) 서브 모듈의 두 번째 commit ID 7e39f89295c7886ce1c60aa67a205063fe52e146 가 보여지고 있네요.\n서브모듈 실습 준비 실제 Github 활용해서 간단하게 테스트 해보려고 합니다. 아래와 같이 TestMain (Public Repository) 와 TestSub (Private Repository) 총 2개의 Repository를 생성했습니다.\nTestMain에는 README.md 파일만 존재하고\nTestSub에는 아래와 같이 test.properites 라는 파일과 README.md 파일이 존재합니다.\n실습 우선 다음과 같이 TestMain 레파지토리를 clone 합니다.\n1 2 3 4 5 6 7 hyungkeunchoi@HyungKeunui-MacBookPro DeskTop % git clone https://github.com/ChoiHyungKuen/TestMain Cloning into \u0026#39;TestMain\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. hyungkeunchoi@HyungKeunui-MacBookPro DeskTop % 이후 아래와 같이 명령어로 TestMain 폴더로 이동 후 TestSub 레파지토리를 sub라는 이름으로 서브 프로젝트를 생성합니다.\n1 2 3 4 5 6 7 8 9 hyungkeunchoi@HyungKeunui-MacBookPro DeskTop % cd TestMain hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git submodule add https://github.com/ChoiHyungKuen/TestSub.git sub Cloning into \u0026#39;/Users/hyungkeunchoi/Desktop/TestMain/sub\u0026#39;... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. hyungkeunchoi@HyungKeunui-MacBookPro TestMain % 이후에 TestMain 폴더를 VisualStudioCode로 열어서 폴더 구조를 확인 합니다.\n그러면 아래와 같이 .gitmodules 파일에 sub 라는 이름으로 TestSub 레파지토리가 서브 모듈로 생성되었다는 것을 확인 할 수 있습니다. 여기서 주목할 점은 TestSub가 아닌 sub 라는 이름으로 실제 폴더가 만들어졌다는 점입니다. 이렇게 만들어지면 일반적인 폴더와 똑같이 사용하면 됩니다.\n이후에 해당 서브모듈을 원격 저장소에 push를 하려면 다음과 같이 명령어를 입력하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git add . hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git commit -m \u0026#34;feat: add submodules\u0026#34; [main 870693c] feat: add submodules 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub hyungkeunchoi@HyungKeunui-MacBookPro TestMain % git push Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 8 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 397 bytes | 397.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/ChoiHyungKuen/TestMain 4b799a8..870693c main -\u0026gt; main hyungkeunchoi@HyungKeunui-MacBookPro TestMain % 그러면 아래와 같이 sub@d940787이라는 이름으로 서브모듈이 생긴 것을 확인 할 수 있습니다. 로그인 했을 때는 클릭하면 기존의 TestSub 레파지토리인 것을 확인할 수 있습니다.\n로그인 안 된 상태에서 해당 레파지토리에서 서브모듈을 클릭하게 되면 Private 레파지토리이기때문에 아래와 같이 404페이지를 띄워주어서 확인이 불가능 합니다.\n후기 해당 방법을 통해 민감 파일들을 private 레파지토리 하나를 생성해서 관리하는데 용이할 수 있습니다.\n프로젝트에는 데이터베이스 관련 설정, AWS 관련 설정, API Key와 같은 민감 데이터가 포함될 수 있습니다. 당연히 이와 같은 정보는 하드 코딩해선 안 되고, 별도의 설정 파일로 관리해야 한다. 그래서 SpringBoot에서는 application.properties 파일이나, application.yml 파일을 이용해 설정을 관리하는 것이 일반적입니다.\n설정 파일을 별도로 관리함으로써 얻을 수 있는 또 하나의 이점은, 각 환경에 따라 다른 설정을 적용할 수 있다는 것입니다. 즉, 로컬 환경(local-env), 개발 환경(dev-env), 운영 환경(prod-env), 테스트 환경(test-env)별로 다른 설정을 사용할 수 있게 됩니다.\n문제는 설정 파일을 팀원들과 어떻게 공유할 것인가 입니다. 설정 파일은 다른 사람에겐 공개되지 않으면서, 팀원들 간에는 원활히 공유되어야 합니다. 이러한 문제를 해결하는데 서브모듈을 활용할 수 있을 것입니다.\n위 실습과 여러가지 자료를 찾아본 종합적인 결과를 봤을 때, 개인적인 생각으로는 수정하지 않는 설정 파일이나 Key파일처럼 읽기만 하는 파일을 공유할 수 있는 비공개 레파지토리로 공유하는 것은 좋은 방법일 수 있습니다. 하지만 변경이 주기적으로 필요한 파일이 있는 경우에는 서브모듈 레파지토리를 따로 업데이트 해줘야 하기 때문에 번거로울 수 있을 것 같습니다.\nReference ","date":"2024-01-18T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/git-submodule-%EC%A0%95%EB%A6%AC/","title":"Git Submodule 정리"},{"content":"이번에 일감을 처리하다가 특정 URL에 대한 메뉴 정보를 어떻게 받아오는지 어떻게 처리하는지를 찾다가 해당 내용을 정리하면 좋을 것 같아서 적어본다.\nHandlerInterceptor는 특정한 URI 호출을 \u0026lsquo;가로채는\u0026rsquo; 역할을 합니다. 이를 이용하여 기존 컨트롤러의 로직을 수정하지 않고도, 사전이나 사후 제어가 가능합니다.\nHandlerIntercepter 제공 내부 메서드 1. preHandle(request, response, handler) 지정된 컨트롤러의 동작 이전에 수행할 동작 (사전 제어)\n2. postHandle(request, response, handler, modelAndView) 지정된 컨트롤러의 동작 이후에 처리할 동작 (사후 제어).\nSpring MVC의 Dispatcher Servlet이 화면을 처리하기 전에 동작.\n3. afterCompletion(request, reponse, handler, exception) Dispatcher Servlet의 화면 처리가 완료된 이후 처리할 동작.\nHandlerIntercepter와 Filter의 차이 두 기능 모두 특정 URI에 접근할 때 제어하는 용도로 사용됩니다. 두 기능의 가장 큰 차이는 Context(실행 영역)에 있습니다.\nFilter는 웹 어플리케이션 내에서 동작하기 때문에 Spring Context에 접근하기 어렵습니다.\n반면 Interceptor의 경우 Spring 영역 내에서 동작하기 때문에, Spring Context에 접근하기 용이합니다.\n주로 웹 애플리케이션에서는 이를 상속 받아서 AuthIntercepter 같은 이름의 클래스로 생성해서 특정 URL에 접근할 때 사용자의 권한에 따라 접근할 수 있는지 없는지 확인하는 용도로 사용한다.\n주로 다음의 형태로 사용된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SVG 안에 있는 텍스트는 css처럼 말줌임 옵션을 사용할 수 없어서 따로 로직 추가 function setEllipsisToText() { var self = d3.select(this), textLength = self.node().getComputedTextLength(), text = self.text(); // textLength (길이) 가 50이 넘으면 ... 표시 while (textLength \u0026gt; 50 \u0026amp;\u0026amp; text.length \u0026gt; 0) { text = text.slice(0, -1); self.text(text + \u0026#34;...\u0026#34;); textLength = self.node().getComputedTextLength(); } } // 이후에 text 태그를 순회하면서 자식태그인 tspan태그의 text를 다음과 같이 변경해주면 된다. $(\u0026#34;#amcharts_\u0026#34; + cid) .find(\u0026#34;text\u0026#34;) .each(function () { $(this) .find(\u0026#34;tspan\u0026#34;) .text(function (d) { return d.name; }) .each(setEllipsisToText); }); ","date":"2024-01-18T00:00:00Z","permalink":"https://choihyungkuen.github.io/p/handlerintercepter/","title":"HandlerIntercepter"}]